# 12 вариант

# Подробное описание работы кода по шагам
## Шаг 1: Инициализация графа
python
graph = {
    0: [1, 2, 3],
    1: [0, 2, 4, 5],
    # ... остальные вершины
}
vertices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
### Что происходит: Создается структура данных графа в виде словаря смежности, где ключ - номер вершины, значение - список смежных вершин.
## Шаг 2: Функция подсчета конфликтов
python
def count_conflicts(coloring):
    conflicts = 0
    for vertex in vertices:
        for neighbor in graph[vertex]:
            if coloring[vertex] == coloring[neighbor]:
                conflicts += 1
    return conflicts // 2
### Что происходит:
Проходим по всем вершинам графа
Для каждой вершины проверяем всех ее соседей
Если цвет вершины совпадает с цветом соседа, увеличиваем счетчик конфликтов
Делим результат на 2, так как каждое ребро проверяется дважды
## Шаг 3: Основной алгоритм имитации отжига
python
def simulated_annealing():
    for num_colors in range(1, 11):
        # Шаг 3.1: Создание начальной раскраски
        coloring = {}
        for vertex in vertices:
            coloring[vertex] = random.randint(0, num_colors - 1)
### Что происходит: Для каждого количества цветов от 1 до 10 создается случайная начальная раскраска.
## Шаг 4: Параметры алгоритма отжига
python
temperature = 100.0
cooling_rate = 0.95
min_temperature = 0.1
iteration = 0
### Что происходит: Устанавливаются начальные параметры:
Начальная температура: 100.0
Коэффициент охлаждения: 0.95 (температура умножается на это значение каждый шаг)
Минимальная температура: 0.1 (алгоритм останавливается при достижении)
## Шаг 5: Главный цикл отжига
python
while temperature > min_temperature:
    current_conflicts = count_conflicts(coloring)
    
    # Вывод прогресса каждые 50 итераций
    if iteration % 50 == 0:
        print(f"Температура: {temperature:.2f}, Конфликтов: {current_conflicts}")
### Что происходит: На каждой итерации подсчитывается текущее количество конфликтов и выводится прогресс.
## Шаг 6: Проверка нахождения решения
python
if current_conflicts == 0:
    print(f"Найдена допустимая раскраска с {num_colors} цветами!")
    return coloring, num_colors
### Что происходит: Если конфликтов нет - решение найдено, алгоритм завершается.
## Шаг 7: Генерация соседнего решения
python
new_coloring = coloring.copy()
random_vertex = random.choice(vertices)
current_color = new_coloring[random_vertex]

possible_colors = [c for c in range(num_colors) if c != current_color]
if possible_colors:
    new_coloring[random_vertex] = random.choice(possible_colors)
### Что происходит:

Создается копия текущей раскраски

Выбирается случайная вершина

Генерируется список возможных новых цветов (все, кроме текущего)

Вершине присваивается случайный новый цвет из возможных

## Шаг 8: Критерий принятия решения
python
new_conflicts = count_conflicts(new_coloring)
delta = new_conflicts - current_conflicts

if delta < 0:
    coloring = new_coloring
else:
    probability = math.exp(-delta / temperature)
    if random.random() < probability:
        coloring = new_coloring
### Что происходит:

Если новое решение лучше (delta < 0) - всегда принимаем его

Если хуже - принимаем с вероятностью exp(-delta/temperature)

Вероятность принятия худшего решения уменьшается с понижением температуры

## Шаг 9: Охлаждение
python
temperature *= cooling_rate
iteration += 1
### Что происходит: Температура уменьшается, счетчик итераций увеличивается.

## Шаг 10: Завершение и вывод результатов
python
result_coloring, colors_used = simulated_annealing()

if result_coloring:
    print(f"Количество использованных цветов: {colors_used}")
    print(f"Раскраска вершин: {result_coloring}")
### Что происходит: Выводится найденное решение - количество цветов и раскраска вершин.



# временная сложность
O(K × I × V × E)

## Компоненты:

K = 10 - тестируемые цвета (1..10)

I ≈ 230 - итерации отжига (100°→0.1° с cooling=0.95)

V = 10 - вершины

E = 15 - рёбра

# Объяснение:

Внешний цикл: O(K) - по количеству цветов

Цикл отжига: O(I) - пока температура > min_temp

Подсчёт конфликтов: O(V × E) - для каждой вершины проверяем соседей

Остальные операции: O(1) - константное время

Расчёт: 10 × 230 × 10 × 15 = 345,000 операций





# Пример ввода
<img width="278" height="50" alt="image" src="https://github.com/user-attachments/assets/50d6250a-b9c4-4d8f-9f02-da78ae85a86b" />


# Пример вывода
Попытка раскраски с 1 цветами:
Температура: 100.00, Конфликтов: 15
Температура: 7.69, Конфликтов: 15
Температура: 0.59, Конфликтов: 15

Попытка раскраски с 2 цветами:
Температура: 100.00, Конфликтов: 5
Температура: 7.69, Конфликтов: 7
Температура: 0.59, Конфликтов: 4

Попытка раскраски с 3 цветами:
Температура: 100.00, Конфликтов: 5
Температура: 7.69, Конфликтов: 6
Температура: 0.59, Конфликтов: 3

Попытка раскраски с 4 цветами:
Температура: 100.00, Конфликтов: 4
Найдена допустимая раскраска с 4 цветами!

Количество использованных цветов: 4
Раскраска вершин: {0: 3, 1: 2, 2: 0, 3: 1, 4: 3, 5: 0, 6: 1, 7: 3, 8: 0, 9: 0}


# ответ на 12 контрольный вопрос
##Определение критерия Метрополиса
Критерий Метрополиса — это вероятностное правило принятия решений в алгоритме имитации отжига, которое определяет, следует ли переходить к новому решению, даже если оно ухудшает целевую функцию.
## Критерий Метрополиса в имитации отжига
### Основная формула:
P(принять) = exp(-ΔE / T)

где:

ΔE = new_energy - current_energy (разница качества решений)

T - текущая температура

P - вероятность принятия нового решения

## Логика принятия решений:
python
delta = new_conflicts - current_conflicts

if delta < 0:
    # УЛУЧШЕНИЕ - принимаем всегда
    accept = True
else:
    # УХУДШЕНИЕ - принимаем с вероятностью exp(-delta/temperature)
    probability = math.exp(-delta / temperature)
    accept = random.random() < probability
## Ключевые особенности:
На старте (высокая T) - алгоритм активно исследует пространство решений

В процессе (средняя T) - баланс между исследованием и оптимизацией

В конце (низкая T) - алгоритм "застывает" в локальном минимуме

Это позволяет избегать застревания в плохих локальных минимумах на ранних стадиях алгоритма.
